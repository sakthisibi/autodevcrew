from langchain_openai import ChatOpenAI
from langchain_core.prompts import PromptTemplate
from langchain_core.output_parsers import PydanticOutputParser
from pydantic import BaseModel, Field

class CodeGeneration(BaseModel):
    code: str = Field(description="Generated Python code")
    explanation: str = Field(description="Explanation of the code")

def generate_code(task_description):
    # Note: Assuming Ollama running locally. Adjust base_url/api_key if needed.
    # Standard ChatOpenAI attempts to connect to OpenAI API.
    # For Ollama usage with LangChain's ChatOpenAI wrapper:
    llm = ChatOpenAI(
        model_name="llama2", 
        temperature=0.7,
        base_url="http://localhost:11434/v1", # Typical Ollama endpoint
        api_key="ollama" # Required for local non-OpenAI usage
    )
    prompt = PromptTemplate(
        template="Generate Python code for: {description}\n\nReturn only the code.",
        input_variables=["description"]
    )
    # Note: PydanticOutputParser instructions need to be injected into the prompt
    # or the model might not follow JSON structure perfectly without instructions.
    # But following "Return only the code" user prompt strictly.
    # However, to use the parser, we usually do:
    parser = PydanticOutputParser(pydantic_object=CodeGeneration)
    
    # We should add formatting instructions to the prompt if we want the parser to work
    prompt.template += "\n{format_instructions}"
    
    formatted_prompt = prompt.format(
        description=task_description,
        format_instructions=parser.get_format_instructions()
    )
    
    try:
        response = llm.invoke(formatted_prompt)
        content = response.content
    except Exception as e:
        print(f"\n⚠️  LLM Connection Failed: {str(e)}")
        print("ℹ️  Switching to SMART DEMO MODE (Pattern-based Generation).")
        
        task_lower = task_description.lower()
        
        if "login" in task_lower or "signup" in task_lower:
            content = """
```python
# Generated by AutoDevCrew - Login Module
def authenticate_user(username, password):
    \"\"\"
    Authenticates a user against a mock database.
    \"\"\"
    users = {"admin": "password123", "user": "guest"}
    if username in users and users[username] == password:
        return True, "Login Successful"
    return False, "Invalid Credentials"

# Example Usage
if __name__ == "__main__":
    success, msg = authenticate_user("admin", "password123")
    print(f"Status: {msg}")
```
"""
        elif "calculator" in task_lower:
            content = """
```python
# Generated by AutoDevCrew - Calculator Module
class Calculator:
    def add(self, a, b): return a + b
    def subtract(self, a, b): return a - b
    def multiply(self, a, b): return a * b
    def divide(self, a, b): 
        if b == 0: return "Error: Division by zero"
        return a / b

if __name__ == "__main__":
    calc = Calculator()
    print(f"10 + 5 = {calc.add(10, 5)}")
```
"""
        elif "data" in task_lower or "csv" in task_lower or "json" in task_lower:
            content = """
```python
# Generated by AutoDevCrew - Data Processor
import json

def process_data(input_json):
    try:
        data = json.loads(input_json)
        # Summary statistics
        result = {
            "count": len(data),
            "keys": list(data[0].keys()) if data else []
        }
        return result
    except Exception as e:
        return {"error": str(e)}

if __name__ == "__main__":
    test_data = '[{"id": 1, "val": "a"}, {"id": 2, "val": "b"}]'
    print(process_data(test_data))
```
"""
        else:
            # General fallback
            content = f"""
```python
# Generated by AutoDevCrew - Generic Task
# Task: {task_description}

def execute_task():
    print("Executing: {task_description}")
    return True

if __name__ == "__main__":
    execute_task()
```
"""

    try:
        parsed_output = parser.parse(content)
        return parsed_output.code
    except Exception as e:
        # Fallback: Try to extract code from markdown blocks
        if "```python" in content:
            return content.split("```python")[1].split("```")[0].strip()
        elif "```html" in content:
            return content.split("```html")[1].split("```")[0].strip()
        elif "```" in content:
            block = content.split("```")[1]
            if "\n" in block:
                first_line = block.split("\n")[0].strip()
                if first_line.isalnum(): 
                    block = block[len(first_line):]
            return block.split("```")[0].strip()
        return content
